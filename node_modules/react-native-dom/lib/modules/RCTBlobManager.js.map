{"version":3,"sources":["../../ReactDom/modules/RCTBlobManager.js"],"names":["kBlobURIScheme","RCTBlobManager","bridge","blobs","BLOB_URI_SCHEME","BLOB_URI_HOST","data","blobId","storeWithId","blob","offset","size","resolveWithOffsetAndSize","url","parsedUrl","URL","pathname","parseInt","searchParams","get","slice","networking","addRequestHandler","addResponseHandler","resolve","contentType","blobType","type","body","responseType","response","Blob","store","name","getResponseHeader","RCTModule","moduleName"],"mappings":"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","sourcesContent":["/** @flow */\n\nimport cuid from \"cuid\";\nimport invariant from \"invariant\";\n\nimport RCTModule from \"RCTModule\";\nimport type RCTBridge from \"RCTBridge\";\nimport type {\n  RCTHttpRequest,\n  RCTNetworkingRequestHandler,\n  RCTNetworkingResponseHandler\n} from \"RCTNetworkingNative\";\n\nconst kBlobURIScheme = \"blob\";\n\nclass RCTBlobManager extends RCTModule\n  implements RCTNetworkingRequestHandler, RCTNetworkingResponseHandler {\n  static moduleName = \"BlobModule\";\n\n  blobs: { [key: string]: Blob };\n\n  constructor(bridge: RCTBridge) {\n    super(bridge);\n    this.blobs = {};\n  }\n\n  constantsToExport() {\n    return {\n      BLOB_URI_SCHEME: kBlobURIScheme,\n      BLOB_URI_HOST: null\n    };\n  }\n\n  store(data: Blob) {\n    const blobId = cuid();\n    this.storeWithId(data, blobId);\n    return blobId;\n  }\n\n  storeWithId(data: Blob, blobId: string) {\n    this.blobs[blobId] = data;\n  }\n\n  resolve(blob: Object) {\n    const blobId: string = blob[\"blobId\"];\n    const offset: number = blob[\"offset\"];\n    const size: number = blob[\"size\"];\n    return this.resolveWithOffsetAndSize(blobId, offset, size);\n  }\n\n  resolveURL(url: string) {\n    const parsedUrl = new URL(url);\n    const blobId = parsedUrl.pathname;\n    const offset = parseInt(parsedUrl.searchParams.get(\"offset\"), 10);\n    const size = parseInt(parsedUrl.searchParams.get(\"size\"), 10);\n    return this.resolveWithOffsetAndSize(blobId, offset, size);\n  }\n\n  resolveWithOffsetAndSize(blobId: string, offset: number, size: number) {\n    let data = this.blobs[blobId];\n    if (!data) {\n      return null;\n    }\n    if (offset != 0 || (size != -1 && size != data.size)) {\n      data = data.slice(offset, offset + size);\n    }\n    return data;\n  }\n\n  $addNetworkingHandler() {\n    this.bridge.networking.addRequestHandler(this);\n    this.bridge.networking.addResponseHandler(this);\n  }\n\n  $release(blobId: string) {\n    delete this.blobs[blobId];\n  }\n\n  canHandleNetworkingRequest(data: Object): boolean {\n    return data.blob != null;\n  }\n\n  handleNetworkingRequest(data: Object): Object {\n    const blob: ?Blob = this.resolve(data.blob);\n    invariant(blob, `Could not resolve blob ${data.blob}`);\n\n    let contentType = \"application/octet-stream\";\n    const blobType = blob.type;\n    if (blobType != null && blob.size !== 0) {\n      contentType = blob.type;\n    }\n    return { body: blob, contentType };\n  }\n\n  canHandleNetworkingResponse(responseType: string): boolean {\n    return responseType === \"blob\";\n  }\n\n  handleNetworkingResponse(response: RCTHttpRequest, data: Blob): Object {\n    data = data ? data : new Blob();\n    return {\n      blobId: this.store(data),\n      offset: 0,\n      size: data.size,\n      name: null,\n      type: response.getResponseHeader(\"content-type\")\n    };\n  }\n}\n\nexport default RCTBlobManager;\n"],"file":"RCTBlobManager.js"}