{"version":3,"sources":["../../ReactDom/modules/RCTTiming.js"],"names":["IDLE_CALLBACK_THRESHOLD","now","window","performance","Date","RCTTiming","bridge","timers","sendIdleEvents","targetFrameDuration","callbackId","duration","jsSchedulingTime","repeats","currentTimeMillis","currentDateNowTimeMillis","adjustedDuration","Math","max","initialTargetTime","timer","String","enqueueJSCall","sendIdle","toRemove","time","t","push","length","frameStart","frameNow","frameElapsed","Object","keys","RCTModule","moduleName"],"mappings":"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","sourcesContent":["/** @flow */\n\nimport RCTModule from \"RCTModule\";\nimport type RCTBridge from \"RCTBridge\";\n\ntype Timer = {\n  callbackId: number,\n  duration: number,\n  jsSchedulingTime: number,\n  repeats: boolean\n};\n\nconst IDLE_CALLBACK_THRESHOLD = 1; // Minimum idle execution time of 1ms\n\nfunction now() {\n  return window.performance ? performance.now() : Date.now();\n}\n\nclass RCTTiming extends RCTModule {\n  static moduleName = \"RCTTiming\";\n\n  timers: { [callbackId: string]: Timer };\n  sendIdleEvents: boolean;\n  targetFrameDuration: number;\n\n  constructor(bridge: RCTBridge) {\n    super(bridge);\n\n    this.timers = {};\n    this.sendIdleEvents = false;\n    this.targetFrameDuration = 1000.0 / 60.0; // 60fps\n  }\n\n  $createTimer(\n    callbackId: number,\n    duration: number,\n    jsSchedulingTime: number,\n    repeats: boolean\n  ) {\n    const currentTimeMillis = now();\n    const currentDateNowTimeMillis = jsSchedulingTime + 1000 / 60;\n    const adjustedDuration = Math.max(\n      0.0,\n      jsSchedulingTime - currentDateNowTimeMillis + duration\n    );\n    const initialTargetTime = currentTimeMillis + adjustedDuration;\n\n    const timer = {\n      callbackId,\n      duration,\n      jsSchedulingTime: initialTargetTime,\n      repeats\n    };\n\n    if (adjustedDuration === 0) {\n      if (timer.repeats) {\n        timer.jsSchedulingTime += timer.duration;\n        this.timers[String(callbackId)] = timer;\n      }\n      this.bridge.enqueueJSCall(\"JSTimers\", \"callTimers\", [[callbackId]]);\n    } else {\n      this.timers[String(callbackId)] = timer;\n    }\n  }\n\n  $deleteTimer(callbackId: number) {\n    delete this.timers[String(callbackId)];\n  }\n\n  $setSendIdleEvents(sendIdle: boolean) {\n    this.sendIdleEvents = sendIdle;\n  }\n\n  async frame() {\n    const toRemove = [];\n    const timers = [];\n    const time = now();\n\n    for (const timer in this.timers) {\n      const t = this.timers[timer];\n      if (t.jsSchedulingTime <= time) {\n        timers.push(this.timers[timer].callbackId);\n        if (t.repeats) {\n          t.jsSchedulingTime += t.duration;\n        } else {\n          toRemove.push(timer);\n        }\n      }\n    }\n\n    // timer information is distributed in a single message with mulitiple params\n    // which minimizes the bridge traffic when many timers are used\n    if (timers.length) {\n      this.bridge.enqueueJSCall(\"JSTimers\", \"callTimers\", [timers]);\n    }\n\n    for (const timer of toRemove) {\n      delete this.timers[timer];\n    }\n  }\n\n  async idle(frameStart: number) {\n    if (!this.sendIdleEvents) {\n      return;\n    }\n    const frameNow = now();\n    const frameElapsed = frameNow - frameStart;\n    if (this.targetFrameDuration - frameElapsed >= IDLE_CALLBACK_THRESHOLD) {\n      this.bridge.enqueueJSCall(\"JSTimers\", \"callIdleCallbacks\", [\n        Date.now() - frameElapsed\n      ]);\n    }\n  }\n\n  shouldContinue(): boolean {\n    return Object.keys(this.timers).length !== 0;\n  }\n}\n\nexport default RCTTiming;\n"],"file":"RCTTiming.js"}