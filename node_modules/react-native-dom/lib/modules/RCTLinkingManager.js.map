{"version":3,"sources":["../../ReactDom/modules/RCTLinkingManager.js"],"names":["ALLOWED_PROTOCOLS","RCTLinkingManager","protocol","loc","pathname","search","hash","bridge","handleUrlChange","location","sendEventWithName","url","decodeURIComponent","locationToString","selfProtocol","history","getModuleByName","urlScheme","stopListening","listen","parsedUrl","URL","prevUrl","currentUrl","nextUrl","href","substr","length","$push","includes","window","toString","Error","concat","RCTEventEmitter","moduleName"],"mappings":"4sBAMA,sFAGA,GAAMA,CAAAA,iBAAiB,CAAG,CACxB,UADwB,CAExB,MAFwB,CAGxB,KAHwB,CAIxB,MAJwB,CAKxB,OALwB,CAMxB,SANwB,CAOxB,SAPwB,CAQxB,MARwB,CASxB,OATwB,CAUxB,OAVwB,CAWxB,MAXwB,CAYxB,MAZwB,CAaxB,QAbwB,CAcxB,MAdwB,CAexB,MAfwB,CAgBxB,MAhBwB,CAiBxB,SAjBwB,CAkBxB,OAlBwB,CAmBxB,OAnBwB,CAA1B,C,GA4BMC,CAAAA,iB,iMAGoBC,Q,CAAkBC,G,CAAe,CACvD,MAAUD,CAAAA,QAAV,KAAsBC,GAAG,CAACC,QAA1B,CAAqCD,GAAG,CAACE,MAAzC,CAAkDF,GAAG,CAACG,IAAtD,CACD,C,IAMD,2BAAYC,MAAZ,CAA+B,gEAC7B,6GAAMA,MAAN,GAD6B,MAkB/BC,eAlB+B,CAkBb,SAACC,QAAD,CAA+B,CAC/C,MAAKC,iBAAL,CAAuB,KAAvB,CAA8B,CAC5BC,GAAG,CAAEC,kBAAkB,CACrBX,iBAAiB,CAACY,gBAAlB,CAAmC,MAAKC,YAAxC,CAAsDL,QAAtD,CADqB,CADK,CAA9B,EAKD,CAxB8B,CAE7B,MAAKM,OAAL,CAAeR,MAAM,CAACS,eAAP,CAAuB,SAAvB,CAAf,CACA,MAAKF,YAAL,CAAuBP,MAAM,CAACU,SAA9B,KAH6B,aAI9B,C,oGAEiB,CAChB,MAAO,CAAC,KAAD,CAAP,CACD,C,uDAEgB,CACf,KAAKC,aAAL,CAAqB,KAAKH,OAAL,CAAaI,MAAb,CAAoB,KAAKX,eAAzB,CAArB,CACD,C,qDAEe,CACd,GAAI,KAAKU,aAAT,CAAwB,KAAKA,aAAL,GACzB,C,4CAUeP,G,0KACRS,S,CAAY,GAAIC,CAAAA,GAAJ,CAAQV,GAAR,C,MAGdS,SAAS,CAAClB,QAAV,GAAuB,KAAKY,Y,0BACxBQ,O,CAAUV,kBAAkB,wBAAC,KAAKG,OAAL,CAAaQ,UAAd,8BAA4B,EAA5B,C,CAC5BC,O,IAAaJ,SAAS,CAACK,IAAV,CAAeC,MAAf,CACjB,CAAG,KAAKZ,YAAR,MAAwBa,MADP,C,CAGnB,GAAIH,OAAO,GAAKF,OAAhB,CAAyB,CACvB,KAAKP,OAAL,CAAaa,KAAb,CAAmBJ,OAAnB,EACD,C,kCAEMxB,iBAAiB,CAAC6B,QAAlB,CAA2BT,SAAS,CAAClB,QAArC,C,0BACP4B,MAAM,CAACrB,QAAP,CAAkBW,SAAS,CAACW,QAAV,EAAlB,C,oCAEM,IAAIC,CAAAA,KAAJ,qBAA8BZ,SAAS,CAACW,QAAV,EAA9B,C,yCAGD,I,6GAGUpB,G,mJACI,GAAIU,CAAAA,GAAJ,CAAQV,GAAR,C,CAAbT,Q,MAAAA,Q,kCACD,CAAC,KAAKY,YAAN,EAAoBmB,MAApB,CAA2BjC,iBAA3B,EAA8C6B,QAA9C,CAAuD3B,QAAvD,C,mRAIAD,iBAAiB,CAACY,gBAAlB,CAAmC,KAAKC,YAAxC,CAAsDL,QAAtD,C,0FAjEqByB,8B,EAA1BjC,iB,CACGkC,U,CAAa,mB,cAoEPlC,iB","sourcesContent":["/** @flow */\n\nimport type { BrowserLocation } from \"history/createBrowserHistory\";\n\nimport type RCTBridge from \"RCTBridge\";\nimport type RCTHistory from \"RCTHistory\";\nimport RCTEventEmitter from \"RCTNativeEventEmitter\";\n\n// Taken from https://developer.mozilla.org/en-US/docs/Web/API/Navigator/registerProtocolHandler\nconst ALLOWED_PROTOCOLS = [\n  \"bitcoin:\",\n  \"geo:\",\n  \"im:\",\n  \"irc:\",\n  \"ircs:\",\n  \"magnet:\",\n  \"mailto:\",\n  \"mms:\",\n  \"news:\",\n  \"nntp:\",\n  \"sip:\",\n  \"sms:\",\n  \"smsto:\",\n  \"ssh:\",\n  \"tel:\",\n  \"urn:\",\n  \"webcal:\",\n  \"wtai:\",\n  \"xmpp:\"\n];\n\ntype Location = {\n  pathname: string,\n  search: string,\n  hash: string\n};\n\nclass RCTLinkingManager extends RCTEventEmitter {\n  static moduleName = \"RCTLinkingManager\";\n\n  static locationToString(protocol: string, loc: Location) {\n    return `${protocol}/${loc.pathname}${loc.search}${loc.hash}`;\n  }\n\n  history: RCTHistory;\n  selfProtocol: string;\n  stopListening: ?Function;\n\n  constructor(bridge: RCTBridge) {\n    super(bridge);\n    this.history = bridge.getModuleByName(\"History\");\n    this.selfProtocol = `${bridge.urlScheme}:`;\n  }\n\n  supportedEvents() {\n    return [\"url\"];\n  }\n\n  startObserving() {\n    this.stopListening = this.history.listen(this.handleUrlChange);\n  }\n\n  stopObserving() {\n    if (this.stopListening) this.stopListening();\n  }\n\n  handleUrlChange = (location: BrowserLocation) => {\n    this.sendEventWithName(\"url\", {\n      url: decodeURIComponent(\n        RCTLinkingManager.locationToString(this.selfProtocol, location)\n      )\n    });\n  };\n\n  async $$openURL(url: string) {\n    const parsedUrl = new URL(url);\n\n    // If URL uses custom \"self\" protocol, push the path to history\n    if (parsedUrl.protocol === this.selfProtocol) {\n      const prevUrl = decodeURIComponent(this.history.currentUrl ?? \"\");\n      const nextUrl = `${parsedUrl.href.substr(\n        `${this.selfProtocol}/`.length\n      )}`;\n      if (nextUrl !== prevUrl) {\n        this.history.$push(nextUrl);\n      }\n    } // Otherwise, if url contains a valid protocol, navigate out of page to new url\n    else if (ALLOWED_PROTOCOLS.includes(parsedUrl.protocol)) {\n      window.location = parsedUrl.toString();\n    } else {\n      throw new Error(`Cannot open URL: ${parsedUrl.toString()}`);\n    }\n\n    return true;\n  }\n\n  async $$canOpenURL(url: string) {\n    const { protocol } = new URL(url);\n    return [this.selfProtocol].concat(ALLOWED_PROTOCOLS).includes(protocol);\n  }\n\n  async $$getInitialURL() {\n    return RCTLinkingManager.locationToString(this.selfProtocol, location);\n  }\n}\n\nexport default RCTLinkingManager;\n"],"file":"RCTLinkingManager.js"}