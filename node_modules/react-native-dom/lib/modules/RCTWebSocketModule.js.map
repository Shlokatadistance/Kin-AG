{"version":3,"sources":["../../ReactDom/modules/RCTWebSocketModule.js"],"names":["RCTWebSocketModule","bridge","sockets","url","protocols","options","socketId","socket","WebSocket","binaryType","String","onclose","event","payload","id","code","reason","enqueueJSCall","onerror","message","onmessage","data","ArrayBuffer","arr","Uint8Array","str","Array","byteLength","i","length","fromCharCode","btoa","join","type","onopen","Error","send","_send","chars","atob","array","charCodeAt","buffer","codeOrId","close","RCTEventEmitter","moduleName"],"mappings":"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","sourcesContent":["/** @flow */\n\nimport invariant from \"invariant\";\n\nimport type RCTBridge from \"RCTBridge\";\nimport RCTEventEmitter from \"RCTNativeEventEmitter\";\n\nclass RCTWebSocketModule extends RCTEventEmitter {\n  static moduleName = \"RCTWebSocketModule\";\n\n  sockets: { [id: string]: WebSocket };\n\n  constructor(bridge: RCTBridge) {\n    super(bridge);\n    this.sockets = {};\n  }\n\n  /**\n   * Establish a connection and associate with socketID. socketID is used for future\n   * communication with React\n   * @param url - string Url to connect to\n   * @param protocols - protocols for creating the WebSocket instance\n   * @param options - currently unused\n   * @param socketId - ID used to represent this connection in React\n   */\n  $connect(\n    url: string,\n    protocols: string | Array<string>,\n    options: any,\n    socketId: number\n  ) {\n    const socket = protocols\n      ? new WebSocket(url, protocols)\n      : new WebSocket(url);\n    socket.binaryType = \"arraybuffer\";\n    this.sockets[String(socketId)] = socket;\n\n    // set the onclose, onerror and onmessage functions so that the\n    // React event can be dispatched\n    socket.onclose = (event) => {\n      const payload = {\n        id: socketId,\n        code: event.code,\n        reason: event.reason\n      };\n      this.bridge.enqueueJSCall(\"RCTDeviceEventEmitter\", \"emit\", [\n        \"websocketClosed\",\n        payload\n      ]);\n    };\n    socket.onerror = (event) => {\n      const payload = {\n        id: socketId,\n        message: \"Native WebSocket error\"\n      };\n      this.bridge.enqueueJSCall(\"RCTDeviceEventEmitter\", \"emit\", [\n        \"websocketFailed\",\n        payload\n      ]);\n    };\n    socket.onmessage = (event) => {\n      let data = event.data;\n      if (data instanceof ArrayBuffer) {\n        // Convert arraybuffer to string because the current bridge format is\n        // automatically stringified to account for metadata and to speed up\n        // older versions of Blink. We may be able to avoid this indirection\n        // later on.\n        const arr = new Uint8Array(data);\n        const str = new Array(arr.byteLength);\n        for (let i = 0; i < str.length; i++) {\n          str[i] = String.fromCharCode(arr[i]);\n        }\n        data = btoa(str.join(\"\"));\n      }\n      const payload = {\n        id: socketId,\n        type: typeof event.data === \"string\" ? \"string\" : \"binary\",\n        data: data\n      };\n      this.bridge.enqueueJSCall(\"RCTDeviceEventEmitter\", \"emit\", [\n        \"websocketMessage\",\n        payload\n      ]);\n    };\n    socket.onopen = (event) => {\n      const payload = {\n        id: socketId\n      };\n      this.bridge.enqueueJSCall(\"RCTDeviceEventEmitter\", \"emit\", [\n        \"websocketOpen\",\n        payload\n      ]);\n    };\n  }\n\n  /**\n   * internal function to send the data\n   * maps the React socketID to the instance of WebSocket\n   */\n  _send(data: string | ArrayBuffer, socketId: number) {\n    const socket = this.sockets[String(socketId)];\n    if (!socket) {\n      throw new Error(\"Error while sending data to WebSocket: no such socket\");\n    }\n    socket.send(data);\n  }\n\n  /**\n   * send\n   * function called by the React code through messages\n   * @param data - data from react\n   * @param socketId - React socket id\n   */\n  $send(data: string, socketId: number) {\n    this._send(data, socketId);\n  }\n\n  /**\n   * sendBinary\n   * function called by the React code through messages\n   * @param data - data from react\n   * @param socketId - React socket id\n   */\n  $sendBinary(data: string, socketId: number) {\n    const chars = atob(data);\n    const array = new Uint8Array(chars.length);\n    for (let i = 0; i < chars.length; i++) {\n      array[i] = chars.charCodeAt(i) & 255;\n    }\n    this._send(array.buffer, socketId);\n  }\n\n  /**\n   * ping\n   * Unsupported in WebVR due to\n   * \"Cannot send a ping. Browser WebSocket APIs are not capable of sending specific opcodes\"\n   * @param socketId - React socket id\n   */\n  $ping(socketId: number) {\n    throw new Error(\n      \"Cannot send a ping. Browser WebSocket APIs are not capable of sending specific opcodes\"\n    );\n  }\n\n  /**\n   * close\n   * function called by the React code through messages\n   * @param codeOrId - if reason is undefined or sockedId is undefined this is id, otherwise\n   *                   it is the code to report to the websocket\n   * @param reason - reason distributed to WebSocket close, maybe undefined\n   * @param socketId - React socket id or maybe undefined in which codeorID contains the socket\n   */\n  $close(codeOrId: number, reason: void | string, socketId: void | number) {\n    let id;\n    if (typeof reason !== \"undefined\" && typeof socketId !== \"undefined\") {\n      id = String(socketId);\n      const socket = this.sockets[id];\n      if (!socket) {\n        return;\n      }\n      socket.close(codeOrId, reason);\n    } else {\n      id = String(codeOrId);\n      const socket = this.sockets[id];\n      if (!socket) {\n        return;\n      }\n      socket.close();\n    }\n    delete this.sockets[id];\n  }\n}\n\nexport default RCTWebSocketModule;\n"],"file":"RCTWebSocketModule.js"}