{"version":3,"sources":["../../ReactDom/modules/RCTUIManagerObserverCoordinator.js"],"names":["RCTUIManagerObserverCoordinator","uiManagerWillPerformLayout","manager","observers","observer","uiManagerDidPerformLayout","uiManagerWillFlushBlocks","Set","add","delete"],"mappings":"yVAEA,iEAEA,gDACA,iF,GA2BMA,CAAAA,+B,YAGJ,0CAAc,wFAkBdC,0BAlBc,CAkBe,SAACC,OAAD,CAA2B,CACtD,kBAAqB,KAAI,CAACC,SAA1B,oLAAqC,uIAA5BC,CAAAA,SAA4B,MACnC,GAAI,MAAOA,CAAAA,SAAQ,CAACH,0BAAhB,GAA+C,UAAnD,CAA+D,CAE7DG,SAAQ,CAACC,yBAAT,CAAmCH,OAAnC,EACD,CACF,CACF,CAzBa,MA2BdG,yBA3Bc,CA2Bc,SAACH,OAAD,CAA2B,CACrD,mBAAqB,KAAI,CAACC,SAA1B,2LAAqC,mJAA5BC,CAAAA,UAA4B,OACnC,GAAI,MAAOA,CAAAA,UAAQ,CAACC,yBAAhB,GAA8C,UAAlD,CAA8D,CAC5DD,UAAQ,CAACC,yBAAT,CAAmCH,OAAnC,EACD,CACF,CACF,CAjCa,MAmCdI,wBAnCc,CAmCa,SAACJ,OAAD,CAA2B,CACpD,mBAAqB,KAAI,CAACC,SAA1B,2LAAqC,mJAA5BC,CAAAA,UAA4B,OACnC,GAAI,MAAOA,CAAAA,UAAQ,CAACE,wBAAhB,GAA6C,UAAjD,CAA6D,CAC3DF,UAAQ,CAACE,wBAAT,CAAkCJ,OAAlC,EACD,CACF,CACF,CAzCa,CACZ,KAAKC,SAAL,CAAiB,GAAII,CAAAA,GAAJ,EAAjB,CACD,C,yGAKWH,Q,CAAgC,CAC1C,KAAKD,SAAL,CAAeK,GAAf,CAAmBJ,QAAnB,EACD,C,sDAKcA,Q,CAAgC,CAC7C,KAAKD,SAAL,CAAeM,MAAf,CAAsBL,QAAtB,EACD,C,4DA4BYJ,+B","sourcesContent":["/** @flow */\n\nimport memoize from \"fast-memoize\";\n\nimport { getPropertyNames } from \"RCTBridge\";\nimport RCTViewManager from \"RCTViewManager\";\nimport type RCTUIManager from \"RCTUIManager\";\n\nexport interface RCTUIManagerObserver {\n  /**\n   * Called just before the UIManager layout views.\n   * It allows performing some operation for components which contain custom\n   * layout logic right before regular Yoga based layout. So, for instance,\n   * some components which have own React-independent state can compute and cache\n   * own intrinsic content size (which will be used by Yoga) at this point.\n   */\n  uiManagerWillPerformLayout?: (manager: RCTUIManager) => void;\n\n  /**\n   * Called just after the UIManager layout views.\n   * It allows performing custom layout logic right after regular Yoga based layout.\n   * So, for instance, this can be used for computing final layout for a component,\n   * since it has its final frame set by Yoga at this point.\n   */\n  uiManagerDidPerformLayout?: (manager: RCTUIManager) => void;\n\n  /**\n   * Called before flushing UI blocks at the end of a batch.\n   */\n  uiManagerWillFlushBlocks?: (manager: RCTUIManager) => void;\n}\n\nclass RCTUIManagerObserverCoordinator implements RCTUIManagerObserver {\n  observers: Set<RCTUIManagerObserver>;\n\n  constructor() {\n    this.observers = new Set();\n  }\n\n  /**\n   * Add a UIManagerObserver. See the `RCTUIManagerObserver` iterface for more info.\n   */\n  addObserver(observer: RCTUIManagerObserver) {\n    this.observers.add(observer);\n  }\n\n  /**\n   * Remove a `UIManagerObserver`.\n   */\n  removeObserver(observer: RCTUIManagerObserver) {\n    this.observers.delete(observer);\n  }\n\n  uiManagerWillPerformLayout = (manager: RCTUIManager) => {\n    for (let observer of this.observers) {\n      if (typeof observer.uiManagerWillPerformLayout === \"function\") {\n        // $FlowFixMe - I don't know why this fails when the other methods don't\n        observer.uiManagerDidPerformLayout(manager);\n      }\n    }\n  };\n\n  uiManagerDidPerformLayout = (manager: RCTUIManager) => {\n    for (let observer of this.observers) {\n      if (typeof observer.uiManagerDidPerformLayout === \"function\") {\n        observer.uiManagerDidPerformLayout(manager);\n      }\n    }\n  };\n\n  uiManagerWillFlushBlocks = (manager: RCTUIManager) => {\n    for (let observer of this.observers) {\n      if (typeof observer.uiManagerWillFlushBlocks === \"function\") {\n        observer.uiManagerWillFlushBlocks(manager);\n      }\n    }\n  };\n}\n\nexport default RCTUIManagerObserverCoordinator;\n"],"file":"RCTUIManagerObserverCoordinator.js"}