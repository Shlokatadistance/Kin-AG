{"version":3,"sources":["../../../../ReactDom/modules/NativeAnimation/Drivers/RCTFrameAnimation.js"],"names":["RCTFrameAnimation","animationId","config","valueNode","callback","toValue","fromValue","value","frames","iterations","currentLoop","animationHasBegun","animationHasFinished","animationStartTime","animationCurrentTime","finished","currentTime","length","currentDuration","startIndex","Math","floor","RCTSingleFrameInterval","nextIndex","firstValue","updateOutputWithFrameOutput","finalValue","fromFrameValue","toFrameValue","fromInterval","toInterval","frameOutput","outputValue","setNeedsUpdate"],"mappings":"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","sourcesContent":["/** @flow */\n\nimport type { Config } from \"RCTNativeAnimatedModule\";\nimport type { RCTAnimationDriver } from \"RCTAnimationDriver\";\nimport type RCTValueAnimatedNode from \"RCTValueAnimatedNode\";\nimport { RCTSingleFrameInterval } from \"RCTAnimationDriver\";\nimport { RCTInterpolateValue } from \"RCTAnimationUtils\";\n\nclass RCTFrameAnimation implements RCTAnimationDriver {\n  animationId: number;\n  valueNode: RCTValueAnimatedNode;\n  animationHasBegun: boolean;\n  animationHasFinished: boolean;\n\n  animationStartTime: number;\n  animationCurrentTime: number;\n\n  frames: number[];\n  toValue: number;\n  fromValue: number;\n  callback: ?Function;\n  iterations: number;\n  currentLoop: number;\n\n  constructor(\n    animationId: number,\n    config: Config,\n    valueNode: RCTValueAnimatedNode,\n    callback: ?Function\n  ) {\n    this.animationId = animationId;\n    this.toValue = config.toValue != null ? config.toValue : 1;\n    this.fromValue = valueNode.value;\n    this.valueNode = valueNode;\n    this.frames = [...config.frames];\n    this.callback = callback;\n    this.iterations = config.iterations != null ? config.iterations : 1;\n    this.currentLoop = 1;\n    this.animationHasBegun = false;\n    this.animationHasFinished = this.iterations === 0;\n    return this;\n  }\n\n  startAnimation() {\n    this.animationStartTime = -1;\n    this.animationCurrentTime = -1;\n    this.animationHasBegun = true;\n  }\n\n  stopAnimation() {\n    // this.valueNode = null;\n    if (this.callback) {\n      this.callback({\n        finished: this.animationHasFinished\n      });\n    }\n  }\n\n  stepAnimationWithTime(currentTime: number) {\n    if (\n      !this.animationHasBegun ||\n      this.animationHasFinished ||\n      this.frames.length === 0\n    ) {\n      // Animation has not begun or animation has already finished.\n      return;\n    }\n\n    if (this.animationStartTime === -1) {\n      this.animationStartTime = this.animationCurrentTime = currentTime;\n    }\n\n    this.animationCurrentTime = currentTime;\n    const currentDuration = this.animationCurrentTime - this.animationStartTime;\n\n    // Determine how many frames have passed since last update.\n    // Get index of frames that surround the current interval\n    const startIndex = Math.floor(currentDuration / RCTSingleFrameInterval);\n    const nextIndex = startIndex + 1;\n\n    if (nextIndex >= this.frames.length) {\n      if (this.iterations == -1 || this.currentLoop < this.iterations) {\n        // Looping, reset to the first frame value.\n        this.animationStartTime = currentTime;\n        this.currentLoop++;\n        const firstValue = this.frames[0];\n        this.updateOutputWithFrameOutput(firstValue);\n      } else {\n        this.animationHasFinished = true;\n        // We are at the end of the animation\n        // Update value and flag animation has ended.\n        const finalValue = this.frames[this.frames.length - 1];\n        this.updateOutputWithFrameOutput(finalValue);\n      }\n      return;\n    }\n\n    // Do a linear remap of the two frames to safegaurd against variable framerates\n    const fromFrameValue = this.frames[startIndex];\n    const toFrameValue = this.frames[nextIndex];\n    const fromInterval = startIndex * RCTSingleFrameInterval;\n    const toInterval = nextIndex * RCTSingleFrameInterval;\n\n    // Interpolate between the individual frames to ensure the animations are\n    //smooth and of the proper duration regardless of the framerate.\n    const frameOutput = RCTInterpolateValue(\n      currentDuration,\n      fromInterval,\n      toInterval,\n      fromFrameValue,\n      toFrameValue,\n      \"extend\",\n      \"extend\"\n    );\n\n    this.updateOutputWithFrameOutput(frameOutput);\n  }\n\n  updateOutputWithFrameOutput(frameOutput: number) {\n    const outputValue = RCTInterpolateValue(\n      frameOutput,\n      0,\n      1,\n      this.fromValue,\n      this.toValue,\n      \"extend\",\n      \"extend\"\n    );\n\n    const valueNode = this.valueNode;\n    if (valueNode) {\n      valueNode.value = outputValue;\n      valueNode.setNeedsUpdate();\n    }\n  }\n}\n\nexport default RCTFrameAnimation;\n"],"file":"RCTFrameAnimation.js"}