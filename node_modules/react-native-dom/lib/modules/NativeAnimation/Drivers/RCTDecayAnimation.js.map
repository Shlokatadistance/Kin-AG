{"version":3,"sources":["../../../../ReactDom/modules/NativeAnimation/Drivers/RCTDecayAnimation.js"],"names":["RCTDecayAnimation","animationId","config","valueNode","callback","fromValue","lastValue","velocity","deceleration","iterations","currentLoop","animationHasFinished","frameStartTime","animationHasBegun","finished","currentTime","RCTSingleFrameInterval","value","updateValue","Math","exp","abs","outputValue","setNeedsUpdate"],"mappings":"yVAKA,wD,GAEMA,CAAAA,iB,YAeJ,2BACEC,WADF,CAEEC,MAFF,CAGEC,SAHF,CAIEC,QAJF,CAKE,sDACA,KAAKH,WAAL,CAAmBA,WAAnB,CACA,KAAKI,SAAL,CAAiB,CAAjB,CACA,KAAKC,SAAL,CAAiB,CAAjB,CACA,KAAKH,SAAL,CAAiBA,SAAjB,CACA,KAAKC,QAAL,CAAgBA,QAAhB,CACA,KAAKG,QAAL,CAAgBL,MAAM,CAACK,QAAvB,CACA,KAAKC,YAAL,CAAoBN,MAAM,CAACM,YAA3B,CACA,KAAKC,UAAL,CAAkBP,MAAM,CAACO,UAAP,EAAqB,IAArB,CAA4BP,MAAM,CAACO,UAAnC,CAAgD,CAAlE,CACA,KAAKC,WAAL,CAAmB,CAAnB,CACA,KAAKC,oBAAL,CAA4B,KAAKF,UAAL,GAAoB,CAAhD,CACA,MAAO,KAAP,CACD,C,kGAEgB,CACf,KAAKG,cAAL,CAAsB,CAAC,CAAvB,CACA,KAAKC,iBAAL,CAAyB,IAAzB,CACD,C,qDAEe,CAEd,GAAI,KAAKT,QAAT,CAAmB,CACjB,KAAKA,QAAL,CAAc,CACZU,QAAQ,CAAE,KAAKH,oBADH,CAAd,EAGD,CACF,C,oEAEqBI,W,CAAqB,CACzC,GAAMZ,CAAAA,SAAS,CAAG,KAAKA,SAAvB,CAEA,GACEA,SAAS,EAAI,IAAb,EACA,CAAC,KAAKU,iBADN,EAEA,KAAKF,oBAHP,CAIE,CAEA,OACD,CAED,GAAI,KAAKC,cAAL,GAAwB,CAAC,CAA7B,CAAgC,CAE9B,KAAKA,cAAL,CAAsBG,WAAW,CAAGC,0CAApC,CAEA,GAAI,KAAKX,SAAL,GAAmB,KAAKC,SAA5B,CAAuC,CAErC,KAAKD,SAAL,CAAiBF,SAAS,CAACc,KAA3B,CACD,CAHD,IAGO,CAEL,KAAKC,WAAL,CAAiB,KAAKb,SAAtB,EACD,CACD,KAAKC,SAAL,CAAiBH,SAAS,CAACc,KAA3B,CACD,CAED,GAAMA,CAAAA,KAAK,CACT,KAAKZ,SAAL,CACC,KAAKE,QAAL,EAAiB,EAAI,KAAKC,YAA1B,CAAD,EACG,EACCW,IAAI,CAACC,GAAL,CACE,EAAE,EAAI,KAAKZ,YAAX,GAA4BO,WAAW,CAAG,KAAKH,cAA/C,CADF,CAFJ,CAFF,CAQA,KAAKM,WAAL,CAAiBD,KAAjB,EAEA,GAAIE,IAAI,CAACE,GAAL,CAAS,KAAKf,SAAL,CAAiBW,KAA1B,EAAmC,GAAvC,CAA4C,CAC1C,GAAI,KAAKR,UAAL,GAAoB,CAAC,CAArB,EAA0B,KAAKC,WAAL,CAAmB,KAAKD,UAAtD,CAAkE,CAChE,KAAKG,cAAL,CAAsB,CAAC,CAAvB,CACA,KAAKF,WAAL,GACD,CAHD,IAGO,CACL,KAAKC,oBAAL,CAA4B,IAA5B,CACA,OACD,CACF,CAED,KAAKL,SAAL,CAAiBW,KAAjB,CACD,C,gDAEWK,W,CAAqB,CAC/B,GAAMnB,CAAAA,SAAS,CAAG,KAAKA,SAAvB,CACA,GAAIA,SAAJ,CAAe,CACbA,SAAS,CAACc,KAAV,CAAkBK,WAAlB,CACAnB,SAAS,CAACoB,cAAV,GACD,CACF,C,8CAGYvB,iB","sourcesContent":["/** @flow */\n\nimport type { Config } from \"RCTNativeAnimatedModule\";\nimport type { RCTAnimationDriver } from \"RCTAnimationDriver\";\nimport type RCTValueAnimatedNode from \"RCTValueAnimatedNode\";\nimport { RCTSingleFrameInterval } from \"RCTAnimationDriver\";\n\nclass RCTDecayAnimation implements RCTAnimationDriver {\n  animationId: number;\n  valueNode: RCTValueAnimatedNode;\n  animationHasBegun: boolean;\n  animationHasFinished: boolean;\n\n  velocity: number;\n  deceleration: number;\n  frameStartTime: number;\n  fromValue: number;\n  lastValue: number;\n  iterations: number;\n  currentLoop: number;\n  callback: ?Function;\n\n  constructor(\n    animationId: number,\n    config: Config,\n    valueNode: RCTValueAnimatedNode,\n    callback: ?Function\n  ) {\n    this.animationId = animationId;\n    this.fromValue = 0;\n    this.lastValue = 0;\n    this.valueNode = valueNode;\n    this.callback = callback;\n    this.velocity = config.velocity;\n    this.deceleration = config.deceleration;\n    this.iterations = config.iterations != null ? config.iterations : 1;\n    this.currentLoop = 1;\n    this.animationHasFinished = this.iterations === 0;\n    return this;\n  }\n\n  startAnimation() {\n    this.frameStartTime = -1;\n    this.animationHasBegun = true;\n  }\n\n  stopAnimation() {\n    // this.valueNode = null;\n    if (this.callback) {\n      this.callback({\n        finished: this.animationHasFinished\n      });\n    }\n  }\n\n  stepAnimationWithTime(currentTime: number) {\n    const valueNode = this.valueNode;\n\n    if (\n      valueNode == null ||\n      !this.animationHasBegun ||\n      this.animationHasFinished\n    ) {\n      // Animation has not begun or animation has already finished.\n      return;\n    }\n\n    if (this.frameStartTime === -1) {\n      // Since this is the first animation step, consider the start to be on the previous frame.\n      this.frameStartTime = currentTime - RCTSingleFrameInterval;\n\n      if (this.fromValue === this.lastValue) {\n        // First iteration, assign _fromValue based on _valueNode.\n        this.fromValue = valueNode.value;\n      } else {\n        // Not the first iteration, reset _valueNode based on _fromValue.\n        this.updateValue(this.fromValue);\n      }\n      this.lastValue = valueNode.value;\n    }\n\n    const value =\n      this.fromValue +\n      (this.velocity / (1 - this.deceleration)) *\n        (1 -\n          Math.exp(\n            -(1 - this.deceleration) * (currentTime - this.frameStartTime)\n          ));\n\n    this.updateValue(value);\n\n    if (Math.abs(this.lastValue - value) < 0.1) {\n      if (this.iterations === -1 || this.currentLoop < this.iterations) {\n        this.frameStartTime = -1;\n        this.currentLoop++;\n      } else {\n        this.animationHasFinished = true;\n        return;\n      }\n    }\n\n    this.lastValue = value;\n  }\n\n  updateValue(outputValue: number) {\n    const valueNode = this.valueNode;\n    if (valueNode) {\n      valueNode.value = outputValue;\n      valueNode.setNeedsUpdate();\n    }\n  }\n}\n\nexport default RCTDecayAnimation;\n"],"file":"RCTDecayAnimation.js"}