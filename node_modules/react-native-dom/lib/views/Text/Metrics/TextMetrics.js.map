{"version":3,"sources":["../../../../ReactDom/views/Text/Metrics/TextMetrics.js"],"names":["TextMetrics","text","style","width","height","lines","lineWidths","lineHeight","maxLineWidth","fontProperties","numberOfLines","Infinity","wordWrap","canvas","_canvas","font","toFontString","measureFont","context","getContext","outputText","split","Array","length","i","lineWidth","measureText","letterSpacing","Math","max","fontSize","min","line","cache","whiteSpace","collapseSpaces","collapseNewlines","canPrependSpaces","wordWrapWidth","tokens","tokenize","token","isNewline","addLine","currIsBreakingSpace","isBreakingSpace","lastIsBreakingSpace","tokenWidth","getFromCache","canBreakWords","breakWords","characters","j","char","k","nextChar","lastChar","canBreakChars","characterWidth","isLastToken","newLine","key","undefined","spacing","slice","_newlines","indexOf","charCodeAt","_breakingSpaces","push","index","_fonts","ascent","descent","_context","metricsString","METRICS_STRING","BASELINE_SYMBOL","ceil","baseline","BASELINE_MULTIPLIER","fillStyle","fillRect","textBaseline","fillText","imagedata","getImageData","data","pixels","idx","stop","properties"],"mappings":"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","sourcesContent":["// @flow\n\n/*\nThe MIT License\n\nCopyright (c) 2013-2017 Mathew Groves, Chad Engler\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\nimport { TextStyle } from \"./TextStyle\";\n\ntype FontMetrics = {\n  ascent: number,\n  descent: number,\n  fontSize: number\n};\n\nexport class TextMetrics {\n  text: string;\n  style: TextStyle;\n  width: number;\n  height: number;\n  lines: string[];\n  lineWidths: number[];\n  lineHeight: number;\n  maxLineWidth: number;\n  fontProperties: FontMetrics;\n\n  constructor(\n    text: string,\n    style: TextStyle,\n    width: number,\n    height: number,\n    lines: string[],\n    lineWidths: number[],\n    lineHeight: number,\n    maxLineWidth: number,\n    fontProperties: FontMetrics\n  ) {\n    this.text = text;\n    this.style = style;\n    this.width = width;\n    this.height = height;\n    this.lines = lines;\n    this.lineWidths = lineWidths;\n    this.lineHeight = lineHeight;\n    this.maxLineWidth = maxLineWidth;\n    this.fontProperties = fontProperties;\n  }\n\n  static _fonts: { [string]: FontMetrics } = {};\n  static _canvas: HTMLCanvasElement;\n  static _context: CanvasRenderingContext2D;\n\n  static measureText(\n    text: string,\n    style: TextStyle,\n    numberOfLines?: number = Infinity,\n    wordWrap?: boolean,\n    canvas?: HTMLCanvasElement = TextMetrics._canvas\n  ) {\n    wordWrap = wordWrap ? wordWrap : style.wordWrap;\n    const font = style.toFontString();\n    const fontProperties = TextMetrics.measureFont(font);\n    const context = canvas.getContext(\"2d\");\n\n    context.font = font;\n\n    const outputText = wordWrap\n      ? TextMetrics.wordWrap(text, style, canvas)\n      : text;\n\n    const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n    const lineWidths = new Array(lines.length);\n    let maxLineWidth = 0;\n\n    for (let i = 0; i < lines.length; i++) {\n      const lineWidth =\n        context.measureText(lines[i]).width +\n        (lines[i].length - 1) * style.letterSpacing;\n\n      lineWidths[i] = lineWidth;\n      maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n    let width = maxLineWidth;\n\n    const lineHeight = style.lineHeight;\n    let height =\n      Math.max(lineHeight, fontProperties.fontSize) +\n      Math.min(numberOfLines - 1, lines.length - 1) * lineHeight;\n\n    return new TextMetrics(\n      text,\n      style,\n      width,\n      height,\n      lines,\n      lineWidths,\n      lineHeight,\n      maxLineWidth,\n      fontProperties\n    );\n  }\n\n  static wordWrap(\n    text: string,\n    style: TextStyle,\n    canvas?: HTMLCanvasElement = TextMetrics._canvas\n  ) {\n    const context = canvas.getContext(\"2d\");\n\n    let width = 0;\n    let line = \"\";\n    let lines = \"\";\n\n    const cache = {};\n    const { letterSpacing, whiteSpace } = style;\n\n    // How to handle whitespaces\n    const collapseSpaces = TextMetrics.collapseSpaces(whiteSpace);\n    const collapseNewlines = TextMetrics.collapseNewlines(whiteSpace);\n\n    // whether or not spaces may be added to the beginning of lines\n    let canPrependSpaces = !collapseSpaces;\n\n    // There is letterSpacing after every char except the last one\n    // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!\n    // so for convenience the above needs to be compared to width + 1 extra letterSpace\n    // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_\n    // ________________________________________________\n    // And then the final space is simply no appended to each line\n    const wordWrapWidth = style.wordWrapWidth + letterSpacing;\n\n    // break text into words, spaces, and newline chars\n    const tokens = TextMetrics.tokenize(text);\n\n    for (let i = 0; i < tokens.length; i++) {\n      // get the word, space or newlineChar\n      let token = tokens[i];\n\n      // if word is a new line\n      if (TextMetrics.isNewline(token)) {\n        // keep the new line\n        if (!collapseNewlines) {\n          lines += TextMetrics.addLine(line);\n          canPrependSpaces = !collapseSpaces;\n          line = \"\";\n          width = 0;\n          continue;\n        }\n\n        // if we should collapse new lines\n        // we simply convert it into a space\n        token = \" \";\n      }\n\n      // if we should collapse repeated whitespaces\n      if (collapseSpaces) {\n        // check both this and the last tokens for spaces\n        const currIsBreakingSpace = TextMetrics.isBreakingSpace(token);\n        const lastIsBreakingSpace = TextMetrics.isBreakingSpace(\n          line[line.length - 1]\n        );\n\n        if (currIsBreakingSpace && lastIsBreakingSpace) {\n          continue;\n        }\n      }\n\n      // get word width from cache if possible\n      const tokenWidth = TextMetrics.getFromCache(\n        token,\n        letterSpacing,\n        cache,\n        context\n      );\n\n      // word is longer than desired bounds\n      if (tokenWidth > wordWrapWidth) {\n        // if we are not already at the beginning of a line\n        if (line !== \"\") {\n          // start newlines for overflow words\n          lines += TextMetrics.addLine(line);\n          line = \"\";\n          width = 0;\n        }\n\n        // break large word over multiple lines\n        if (TextMetrics.canBreakWords(token, style.breakWords)) {\n          // break word into characters\n          const characters = token.split(\"\");\n\n          // loop the characters\n          for (let j = 0; j < characters.length; j++) {\n            let char = characters[j];\n\n            let k = 1;\n            // we are not at the end of the token\n\n            while (characters[j + k]) {\n              const nextChar = characters[j + k];\n              const lastChar = char[char.length - 1];\n\n              // should not split chars\n              if (\n                !TextMetrics.canBreakChars(\n                  lastChar,\n                  nextChar,\n                  token,\n                  j,\n                  style.breakWords\n                )\n              ) {\n                // combine chars & move forward one\n                char += nextChar;\n              } else {\n                break;\n              }\n\n              k++;\n            }\n\n            j += char.length - 1;\n\n            const characterWidth = TextMetrics.getFromCache(\n              char,\n              letterSpacing,\n              cache,\n              context\n            );\n\n            if (characterWidth + width > wordWrapWidth) {\n              lines += TextMetrics.addLine(line);\n              canPrependSpaces = false;\n              line = \"\";\n              width = 0;\n            }\n\n            line += char;\n            width += characterWidth;\n          }\n        }\n\n        // run word out of the bounds\n        else {\n          // if there are words in this line already\n          // finish that line and start a new one\n          if (line.length > 0) {\n            lines += TextMetrics.addLine(line);\n            line = \"\";\n            width = 0;\n          }\n\n          const isLastToken = i === tokens.length - 1;\n\n          // give it its own line if it's not the end\n          lines += TextMetrics.addLine(token, !isLastToken);\n          canPrependSpaces = false;\n          line = \"\";\n          width = 0;\n        }\n      }\n\n      // word could fit\n      else {\n        // word won't fit because of existing words\n        // start a new line\n        if (tokenWidth + width > wordWrapWidth) {\n          // if its a space we don't want it\n          canPrependSpaces = false;\n\n          // add a new line\n          lines += TextMetrics.addLine(line);\n\n          // start a new line\n          line = \"\";\n          width = 0;\n        }\n\n        // don't add spaces to the beginning of lines\n        if (\n          line.length > 0 ||\n          !TextMetrics.isBreakingSpace(token) ||\n          canPrependSpaces\n        ) {\n          // add the word to the current line\n          line += token;\n\n          // update width counter\n          width += tokenWidth;\n        }\n      }\n    }\n\n    lines += TextMetrics.addLine(line, false);\n\n    return lines;\n  }\n\n  /**\n   * Convienience function for logging each line added during the wordWrap\n   * method\n   */\n  static addLine(line: string, newLine: boolean = true) {\n    line = newLine ? `${line}\\n` : line;\n    return line;\n  }\n\n  /**\n   * Gets & sets the widths of calculated characters in a cache object\n   */\n  static getFromCache(\n    key: string,\n    letterSpacing: number,\n    cache: Object,\n    context: CanvasRenderingContext2D\n  ) {\n    let width = cache[key];\n\n    if (width === undefined) {\n      const spacing = key.length * letterSpacing;\n\n      width = context.measureText(key).width + spacing;\n      cache[key] = width;\n    }\n\n    return width;\n  }\n\n  /**\n   * Determines whether we should collapse breaking spaces\n   */\n  static collapseSpaces(whiteSpace: string) {\n    return whiteSpace === \"normal\" || whiteSpace === \"pre-line\";\n  }\n\n  /**\n   * Determines whether we should collapse newLine chars\n   */\n  static collapseNewlines(whiteSpace: string) {\n    return whiteSpace === \"normal\";\n  }\n\n  /**\n   * trims breaking whitespaces from string\n   */\n  static trimRight(text: string) {\n    if (typeof text !== \"string\") {\n      return \"\";\n    }\n\n    for (let i = text.length - 1; i >= 0; i--) {\n      const char = text[i];\n\n      if (!TextMetrics.isBreakingSpace(char)) {\n        break;\n      }\n\n      text = text.slice(0, -1);\n    }\n\n    return text;\n  }\n\n  /**\n   * Determines if char is a newline.\n   */\n  static isNewline(char: string) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n\n    return TextMetrics._newlines.indexOf(char.charCodeAt(0)) >= 0;\n  }\n\n  /**\n   * Determines if char is a breaking whitespace.\n   */\n  static isBreakingSpace(char: string) {\n    if (typeof char !== \"string\") {\n      return false;\n    }\n\n    return TextMetrics._breakingSpaces.indexOf(char.charCodeAt(0)) >= 0;\n  }\n\n  /**\n   * Splits a string into words, breaking-spaces and newLine characters\n   */\n  static tokenize(text: string) {\n    const tokens = [];\n    let token = \"\";\n\n    if (typeof text !== \"string\") {\n      return tokens;\n    }\n\n    for (let i = 0; i < text.length; i++) {\n      const char = text[i];\n\n      if (TextMetrics.isBreakingSpace(char) || TextMetrics.isNewline(char)) {\n        if (token !== \"\") {\n          tokens.push(token);\n          token = \"\";\n        }\n\n        tokens.push(char);\n\n        continue;\n      }\n\n      token += char;\n    }\n\n    if (token !== \"\") {\n      tokens.push(token);\n    }\n\n    return tokens;\n  }\n\n  /**\n   * This method exists to be easily overridden\n   * It allows one to customise which words should break\n   * Examples are if the token is CJK or numbers.\n   * It must return a boolean.\n   */\n  static canBreakWords(token: string, breakWords: boolean) {\n    return breakWords;\n  }\n\n  /**\n   * This method exists to be easily overridden\n   * It allows one to determine whether a pair of characters\n   * should be broken by newlines\n   * For example certain characters in CJK langs or numbers.\n   * It must return a boolean.\n   */\n  static canBreakChars(\n    char: string,\n    nextChar: string,\n    token: string,\n    index: number,\n    breakWords: boolean\n  ) {\n    return true;\n  }\n\n  static measureFont(font: string): FontMetrics {\n    if (TextMetrics._fonts[font]) {\n      return TextMetrics._fonts[font];\n    }\n\n    let ascent: number;\n    let descent: number;\n    let fontSize: number;\n\n    const canvas = TextMetrics._canvas;\n    const context = TextMetrics._context;\n\n    const metricsString =\n      TextMetrics.METRICS_STRING + TextMetrics.BASELINE_SYMBOL;\n    const width = Math.ceil(context.measureText(metricsString).width);\n    let baseline = Math.ceil(\n      context.measureText(TextMetrics.BASELINE_SYMBOL).width\n    );\n    const height = 2 * baseline;\n\n    baseline = (baseline * TextMetrics.BASELINE_MULTIPLIER) | 0;\n\n    canvas.width = width;\n    canvas.height = height;\n\n    context.fillStyle = \"#f00\";\n    context.fillRect(0, 0, width, height);\n\n    context.font = font;\n\n    context.textBaseline = \"alphabetic\";\n    context.fillStyle = \"#000\";\n    context.fillText(metricsString, 0, baseline);\n\n    const imagedata = context.getImageData(0, 0, width, height).data;\n    const pixels = imagedata.length;\n    const line = width * 4;\n\n    let i = 0;\n    let idx = 0;\n    let stop = false;\n\n    // ascent. scan from top to bottom until we find a non red pixel\n    for (i = 0; i < baseline; ++i) {\n      for (let j = 0; j < line; j += 4) {\n        if (imagedata[idx + j] !== 255) {\n          stop = true;\n          break;\n        }\n      }\n      if (!stop) {\n        idx += line;\n      } else {\n        break;\n      }\n    }\n\n    ascent = baseline - i;\n\n    idx = pixels - line;\n    stop = false;\n\n    // descent. scan from bottom to top until we find a non red pixel\n    for (i = height; i > baseline; --i) {\n      for (let j = 0; j < line; j += 4) {\n        if (imagedata[idx + j] !== 255) {\n          stop = true;\n          break;\n        }\n      }\n\n      if (!stop) {\n        idx -= line;\n      } else {\n        break;\n      }\n    }\n\n    descent = i - baseline;\n    fontSize = ascent + descent;\n\n    const properties: FontMetrics = { ascent, descent, fontSize };\n\n    TextMetrics._fonts[font] = properties;\n\n    return properties;\n  }\n\n  // CONSTANTS\n  static METRICS_STRING = \"|Ã‰q\";\n  static BASELINE_SYMBOL = \"M\";\n  static BASELINE_MULTIPLIER = 1.4;\n  static _newlines = [\n    0x000a, // line feed\n    0x000d // carriage return\n  ];\n  static _breakingSpaces = [\n    0x0009, // character tabulation\n    0x0020, // space\n    0x2000, // en quad\n    0x2001, // em quad\n    0x2002, // en space\n    0x2003, // em space\n    0x2004, // three-per-em space\n    0x2005, // four-per-em space\n    0x2006, // six-per-em space\n    0x2008, // punctuation space\n    0x2009, // thin space\n    0x200a, // hair space\n    0x205f, // medium mathematical space\n    0x3000 // ideographic space\n  ];\n}\n"],"file":"TextMetrics.js"}